pub trait ObjectHeapData: Trace + Debug {
    fn get_prototype_of(&self, heap: &mut Heap) -> JsResult<Option<ObjectIndex>>;
    fn set_prototype_of(&self, heap: &mut Heap, prototype: Option<ObjectIndex>) -> JsResult<bool>;
    fn is_extensible(&self, heap: &mut Heap) -> JsResult<bool>;
    fn prevent_extensions(&self, heap: &mut Heap) -> JsResult<bool>;
    fn get_own_property(
        &self,
        heap: &mut Heap,
        key: PropertyKey,
    ) -> JsResult<Option<PropertyDescriptor>>;
    fn define_own_property(
        &self,
        heap: &mut Heap,
        key: PropertyKey,
        descriptor: PropertyDescriptor,
    ) -> JsResult<bool>;
    fn has_property(&self, heap: &mut Heap, key: PropertyKey) -> JsResult<bool>;
    fn get(&self, heap: &mut Heap, key: PropertyKey, receiver: &Value) -> JsResult<Value>;
    fn set(
        &self,
        heap: &mut Heap,
        key: PropertyKey,
        value: Value,
        receiver: &Value,
    ) -> JsResult<bool>;
    fn delete(&self, heap: &mut Heap, key: PropertyKey) -> JsResult<bool>;
    fn own_property_keys(&self, heap: &mut Heap) -> JsResult<Vec<PropertyKey>>;

    // Tracing helpers
    fn get_strong_references(&self) -> Vec<Value>;
    fn get_weak_references(&self) -> Vec<Value>;
}

pub trait FunctionHeapData: ObjectHeapData {
    fn call(&self, this: &Value, args: &[Value]) -> JsResult<Value>;
}

pub trait ConstructorHeapData: FunctionHeapData {
    fn construct(&self, args: &[Value], target: ObjectIndex) -> JsResult<Value>;
}